{
  "filename": "typescript-best-practices.md",
  "title": "TypeScript ベストプラクティス 2025",
  "content": "---\ntitle: TypeScript ベストプラクティス 2025\ndate: 2025-11-12\ntags: [TypeScript, JavaScript, Best Practices]\n---\n\n# TypeScript ベストプラクティス 2025\n\nTypeScriptは、JavaScriptに静的型付けを追加したスーパーセットです。適切に使用することで、バグを減らし、コードの保守性を大幅に向上させることができます。\n\n## 型定義の基本\n\n### プリミティブ型\n\nTypeScriptの基本的な型：\n\n```typescript\n// 基本型\nlet name: string = \"Alice\";\nlet age: number = 30;\nlet isActive: boolean = true;\nlet items: string[] = [\"item1\", \"item2\"];\nlet tuple: [string, number] = [\"age\", 30];\n\n// any は避ける\nlet data: any; // ❌ 避けるべき\nlet data: unknown; // ✅ unknownを使用\n```\n\n### インターフェースと型エイリアス\n\nインターフェースと型エイリアスの使い分け：\n\n```typescript\n// インターフェース: オブジェクトの形状を定義\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\n// 型エイリアス: より柔軟な型定義\ntype Status = \"active\" | \"inactive\" | \"pending\";\ntype UserWithStatus = User & { status: Status };\n```\n\n## ジェネリクス\n\n再利用可能な型安全なコードを書くためのジェネリクス：\n\n```typescript\n// 基本的なジェネリック関数\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n\n// ジェネリック制約\ninterface Lengthwise {\n  length: number;\n}\n\nfunction logLength<T extends Lengthwise>(arg: T): T {\n  console.log(arg.length);\n  return arg;\n}\n\n// 複数の型パラメータ\nfunction merge<T, U>(obj1: T, obj2: U): T & U {\n  return { ...obj1, ...obj2 };\n}\n```\n\n## ユーティリティ型\n\nTypeScriptの組み込みユーティリティ型を活用しましょう：\n\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  age: number;\n}\n\n// Partial: すべてのプロパティをオプショナルに\ntype PartialUser = Partial<User>;\n\n// Pick: 特定のプロパティのみを選択\ntype UserPreview = Pick<User, \"id\" | \"name\">;\n\n// Omit: 特定のプロパティを除外\ntype UserWithoutEmail = Omit<User, \"email\">;\n\n// Readonly: すべてのプロパティを読み取り専用に\ntype ReadonlyUser = Readonly<User>;\n\n// Record: キーと値の型を指定\ntype UserRoles = Record<string, string[]>;\n```\n\n## 型ガード\n\n型の絞り込みを行うための型ガード：\n\n```typescript\n// typeof型ガード\nfunction processValue(value: string | number) {\n  if (typeof value === \"string\") {\n    return value.toUpperCase();\n  }\n  return value.toFixed(2);\n}\n\n// instanceof型ガード\nclass Dog {\n  bark() { console.log(\"Woof!\"); }\n}\n\nclass Cat {\n  meow() { console.log(\"Meow!\"); }\n}\n\nfunction makeSound(animal: Dog | Cat) {\n  if (animal instanceof Dog) {\n    animal.bark();\n  } else {\n    animal.meow();\n  }\n}\n\n// カスタム型ガード\ninterface Fish {\n  swim: () => void;\n}\n\ninterface Bird {\n  fly: () => void;\n}\n\nfunction isFish(pet: Fish | Bird): pet is Fish {\n  return (pet as Fish).swim !== undefined;\n}\n```\n\n## 非同期処理の型付け\n\nPromiseと非同期関数の型定義：\n\n```typescript\n// Promise の型付け\nasync function fetchUser(id: number): Promise<User> {\n  const response = await fetch(`/api/users/${id}`);\n  return response.json();\n}\n\n// エラーハンドリング\ntype Result<T, E = Error> =\n  | { success: true; data: T }\n  | { success: false; error: E };\n\nasync function safelyFetchUser(id: number): Promise<Result<User>> {\n  try {\n    const user = await fetchUser(id);\n    return { success: true, data: user };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error : new Error('Unknown error')\n    };\n  }\n}\n```\n\n## 列挙型（Enum）の使用\n\n列挙型は定数のグループを定義するのに便利です：\n\n```typescript\n// 数値列挙型\nenum Direction {\n  Up = 1,\n  Down,\n  Left,\n  Right\n}\n\n// 文字列列挙型（推奨）\nenum Status {\n  Active = \"ACTIVE\",\n  Inactive = \"INACTIVE\",\n  Pending = \"PENDING\"\n}\n\n// const enum（パフォーマンス向上）\nconst enum LogLevel {\n  Error = \"ERROR\",\n  Warning = \"WARNING\",\n  Info = \"INFO\"\n}\n```\n\n## ベストプラクティス まとめ\n\n1. **strictモードを有効にする**: `tsconfig.json`で`\"strict\": true`を設定\n2. **anyを避ける**: `unknown`や適切な型を使用\n3. **型推論を活用する**: 明示的な型注釈が不要な場合は省略\n4. **ユニオン型を活用する**: 柔軟で型安全なコードを実現\n5. **nullチェックを徹底**: `strictNullChecks`を有効化\n6. **ジェネリクスで再利用性を高める**: 型安全な汎用コードを書く\n\n## 数式の例\n\nTypeScriptでの計算量の表現例：\n\n- **時間計算量**: $O(n \\log n)$\n- **空間計算量**: $O(n)$\n\nより複雑な数式:\n\n$$\nf(x) = \\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2\\pi i \\xi x} d\\xi\n$$\n\n## まとめ\n\nTypeScriptを効果的に使用することで、開発体験と製品の品質を大幅に向上させることができます。継続的に学習し、ベストプラクティスを取り入れていきましょう。\n",
  "html": "<hr>\n<h2>title: TypeScript ベストプラクティス 2025<br>date: 2025-11-12<br>tags: [TypeScript, JavaScript, Best Practices]</h2>\n<h1>TypeScript ベストプラクティス 2025</h1>\n<p>TypeScriptは、JavaScriptに静的型付けを追加したスーパーセットです。適切に使用することで、バグを減らし、コードの保守性を大幅に向上させることができます。</p>\n<h2>型定義の基本</h2>\n<h3>プリミティブ型</h3>\n<p>TypeScriptの基本的な型：</p>\n<pre><code class=\"language-typescript\">// 基本型\nlet name: string = &quot;Alice&quot;;\nlet age: number = 30;\nlet isActive: boolean = true;\nlet items: string[] = [&quot;item1&quot;, &quot;item2&quot;];\nlet tuple: [string, number] = [&quot;age&quot;, 30];\n\n// any は避ける\nlet data: any; // ❌ 避けるべき\nlet data: unknown; // ✅ unknownを使用\n</code></pre>\n<h3>インターフェースと型エイリアス</h3>\n<p>インターフェースと型エイリアスの使い分け：</p>\n<pre><code class=\"language-typescript\">// インターフェース: オブジェクトの形状を定義\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\n// 型エイリアス: より柔軟な型定義\ntype Status = &quot;active&quot; | &quot;inactive&quot; | &quot;pending&quot;;\ntype UserWithStatus = User &amp; { status: Status };\n</code></pre>\n<h2>ジェネリクス</h2>\n<p>再利用可能な型安全なコードを書くためのジェネリクス：</p>\n<pre><code class=\"language-typescript\">// 基本的なジェネリック関数\nfunction identity&lt;T&gt;(arg: T): T {\n  return arg;\n}\n\n// ジェネリック制約\ninterface Lengthwise {\n  length: number;\n}\n\nfunction logLength&lt;T extends Lengthwise&gt;(arg: T): T {\n  console.log(arg.length);\n  return arg;\n}\n\n// 複数の型パラメータ\nfunction merge&lt;T, U&gt;(obj1: T, obj2: U): T &amp; U {\n  return { ...obj1, ...obj2 };\n}\n</code></pre>\n<h2>ユーティリティ型</h2>\n<p>TypeScriptの組み込みユーティリティ型を活用しましょう：</p>\n<pre><code class=\"language-typescript\">interface User {\n  id: number;\n  name: string;\n  email: string;\n  age: number;\n}\n\n// Partial: すべてのプロパティをオプショナルに\ntype PartialUser = Partial&lt;User&gt;;\n\n// Pick: 特定のプロパティのみを選択\ntype UserPreview = Pick&lt;User, &quot;id&quot; | &quot;name&quot;&gt;;\n\n// Omit: 特定のプロパティを除外\ntype UserWithoutEmail = Omit&lt;User, &quot;email&quot;&gt;;\n\n// Readonly: すべてのプロパティを読み取り専用に\ntype ReadonlyUser = Readonly&lt;User&gt;;\n\n// Record: キーと値の型を指定\ntype UserRoles = Record&lt;string, string[]&gt;;\n</code></pre>\n<h2>型ガード</h2>\n<p>型の絞り込みを行うための型ガード：</p>\n<pre><code class=\"language-typescript\">// typeof型ガード\nfunction processValue(value: string | number) {\n  if (typeof value === &quot;string&quot;) {\n    return value.toUpperCase();\n  }\n  return value.toFixed(2);\n}\n\n// instanceof型ガード\nclass Dog {\n  bark() { console.log(&quot;Woof!&quot;); }\n}\n\nclass Cat {\n  meow() { console.log(&quot;Meow!&quot;); }\n}\n\nfunction makeSound(animal: Dog | Cat) {\n  if (animal instanceof Dog) {\n    animal.bark();\n  } else {\n    animal.meow();\n  }\n}\n\n// カスタム型ガード\ninterface Fish {\n  swim: () =&gt; void;\n}\n\ninterface Bird {\n  fly: () =&gt; void;\n}\n\nfunction isFish(pet: Fish | Bird): pet is Fish {\n  return (pet as Fish).swim !== undefined;\n}\n</code></pre>\n<h2>非同期処理の型付け</h2>\n<p>Promiseと非同期関数の型定義：</p>\n<pre><code class=\"language-typescript\">// Promise の型付け\nasync function fetchUser(id: number): Promise&lt;User&gt; {\n  const response = await fetch(`/api/users/${id}`);\n  return response.json();\n}\n\n// エラーハンドリング\ntype Result&lt;T, E = Error&gt; =\n  | { success: true; data: T }\n  | { success: false; error: E };\n\nasync function safelyFetchUser(id: number): Promise&lt;Result&lt;User&gt;&gt; {\n  try {\n    const user = await fetchUser(id);\n    return { success: true, data: user };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error : new Error(&#39;Unknown error&#39;)\n    };\n  }\n}\n</code></pre>\n<h2>列挙型（Enum）の使用</h2>\n<p>列挙型は定数のグループを定義するのに便利です：</p>\n<pre><code class=\"language-typescript\">// 数値列挙型\nenum Direction {\n  Up = 1,\n  Down,\n  Left,\n  Right\n}\n\n// 文字列列挙型（推奨）\nenum Status {\n  Active = &quot;ACTIVE&quot;,\n  Inactive = &quot;INACTIVE&quot;,\n  Pending = &quot;PENDING&quot;\n}\n\n// const enum（パフォーマンス向上）\nconst enum LogLevel {\n  Error = &quot;ERROR&quot;,\n  Warning = &quot;WARNING&quot;,\n  Info = &quot;INFO&quot;\n}\n</code></pre>\n<h2>ベストプラクティス まとめ</h2>\n<ol>\n<li><strong>strictモードを有効にする</strong>: <code>tsconfig.json</code>で<code>&quot;strict&quot;: true</code>を設定</li>\n<li><strong>anyを避ける</strong>: <code>unknown</code>や適切な型を使用</li>\n<li><strong>型推論を活用する</strong>: 明示的な型注釈が不要な場合は省略</li>\n<li><strong>ユニオン型を活用する</strong>: 柔軟で型安全なコードを実現</li>\n<li><strong>nullチェックを徹底</strong>: <code>strictNullChecks</code>を有効化</li>\n<li><strong>ジェネリクスで再利用性を高める</strong>: 型安全な汎用コードを書く</li>\n</ol>\n<h2>数式の例</h2>\n<p>TypeScriptでの計算量の表現例：</p>\n<ul>\n<li><strong>時間計算量</strong>: $O(n \\log n)$</li>\n<li><strong>空間計算量</strong>: $O(n)$</li>\n</ul>\n<p>より複雑な数式:</p>\n<p>$$<br>f(x) = \\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2\\pi i \\xi x} d\\xi<br>$$</p>\n<h2>まとめ</h2>\n<p>TypeScriptを効果的に使用することで、開発体験と製品の品質を大幅に向上させることができます。継続的に学習し、ベストプラクティスを取り入れていきましょう。</p>\n",
  "modifiedDate": "2025-11-16T12:26:30.000Z"
}