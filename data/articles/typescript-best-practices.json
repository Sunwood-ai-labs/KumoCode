{
  "filename": "typescript-best-practices.md",
  "title": "TypeScript ベストプラクティス 2025",
  "content": "---\ntitle: TypeScript ベストプラクティス 2025\ndate: 2025-11-12\ntags: [TypeScript, JavaScript, Best Practices]\n---\n\n# TypeScript ベストプラクティス 2025\n\nTypeScriptは、JavaScriptに静的型付けを追加したスーパーセットです。適切に使用することで、バグを減らし、コードの保守性を大幅に向上させることができます。\n\n## 型定義の基本\n\n### プリミティブ型\n\nTypeScriptの基本的な型：\n\n```typescript\n// 基本型\nlet name: string = \"Alice\";\nlet age: number = 30;\nlet isActive: boolean = true;\nlet items: string[] = [\"item1\", \"item2\"];\nlet tuple: [string, number] = [\"age\", 30];\n\n// any は避ける\nlet data: any; // ❌ 避けるべき\nlet data: unknown; // ✅ unknownを使用\n```\n\n### インターフェースと型エイリアス\n\nインターフェースと型エイリアスの使い分け：\n\n```typescript\n// インターフェース: オブジェクトの形状を定義\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\n// 型エイリアス: より柔軟な型定義\ntype Status = \"active\" | \"inactive\" | \"pending\";\ntype UserWithStatus = User & { status: Status };\n```\n\n## ジェネリクス\n\n再利用可能な型安全なコードを書くためのジェネリクス：\n\n```typescript\n// 基本的なジェネリック関数\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n\n// ジェネリック制約\ninterface Lengthwise {\n  length: number;\n}\n\nfunction logLength<T extends Lengthwise>(arg: T): T {\n  console.log(arg.length);\n  return arg;\n}\n\n// 複数の型パラメータ\nfunction merge<T, U>(obj1: T, obj2: U): T & U {\n  return { ...obj1, ...obj2 };\n}\n```\n\n## ユーティリティ型\n\nTypeScriptの組み込みユーティリティ型を活用しましょう：\n\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  age: number;\n}\n\n// Partial: すべてのプロパティをオプショナルに\ntype PartialUser = Partial<User>;\n\n// Pick: 特定のプロパティのみを選択\ntype UserPreview = Pick<User, \"id\" | \"name\">;\n\n// Omit: 特定のプロパティを除外\ntype UserWithoutEmail = Omit<User, \"email\">;\n\n// Readonly: すべてのプロパティを読み取り専用に\ntype ReadonlyUser = Readonly<User>;\n\n// Record: キーと値の型を指定\ntype UserRoles = Record<string, string[]>;\n```\n\n## 型ガード\n\n型の絞り込みを行うための型ガード：\n\n```typescript\n// typeof型ガード\nfunction processValue(value: string | number) {\n  if (typeof value === \"string\") {\n    return value.toUpperCase();\n  }\n  return value.toFixed(2);\n}\n\n// instanceof型ガード\nclass Dog {\n  bark() { console.log(\"Woof!\"); }\n}\n\nclass Cat {\n  meow() { console.log(\"Meow!\"); }\n}\n\nfunction makeSound(animal: Dog | Cat) {\n  if (animal instanceof Dog) {\n    animal.bark();\n  } else {\n    animal.meow();\n  }\n}\n\n// カスタム型ガード\ninterface Fish {\n  swim: () => void;\n}\n\ninterface Bird {\n  fly: () => void;\n}\n\nfunction isFish(pet: Fish | Bird): pet is Fish {\n  return (pet as Fish).swim !== undefined;\n}\n```\n\n## 非同期処理の型付け\n\nPromiseと非同期関数の型定義：\n\n```typescript\n// Promise の型付け\nasync function fetchUser(id: number): Promise<User> {\n  const response = await fetch(`/api/users/${id}`);\n  return response.json();\n}\n\n// エラーハンドリング\ntype Result<T, E = Error> =\n  | { success: true; data: T }\n  | { success: false; error: E };\n\nasync function safelyFetchUser(id: number): Promise<Result<User>> {\n  try {\n    const user = await fetchUser(id);\n    return { success: true, data: user };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error : new Error('Unknown error')\n    };\n  }\n}\n```\n\n## 列挙型（Enum）の使用\n\n列挙型は定数のグループを定義するのに便利です：\n\n```typescript\n// 数値列挙型\nenum Direction {\n  Up = 1,\n  Down,\n  Left,\n  Right\n}\n\n// 文字列列挙型（推奨）\nenum Status {\n  Active = \"ACTIVE\",\n  Inactive = \"INACTIVE\",\n  Pending = \"PENDING\"\n}\n\n// const enum（パフォーマンス向上）\nconst enum LogLevel {\n  Error = \"ERROR\",\n  Warning = \"WARNING\",\n  Info = \"INFO\"\n}\n```\n\n## ベストプラクティス まとめ\n\n1. **strictモードを有効にする**: `tsconfig.json`で`\"strict\": true`を設定\n2. **anyを避ける**: `unknown`や適切な型を使用\n3. **型推論を活用する**: 明示的な型注釈が不要な場合は省略\n4. **ユニオン型を活用する**: 柔軟で型安全なコードを実現\n5. **nullチェックを徹底**: `strictNullChecks`を有効化\n6. **ジェネリクスで再利用性を高める**: 型安全な汎用コードを書く\n\n## 数式の例\n\nTypeScriptでの計算量の表現例：\n\n- **時間計算量**: $O(n \\log n)$\n- **空間計算量**: $O(n)$\n\nより複雑な数式:\n\n$$\nf(x) = \\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2\\pi i \\xi x} d\\xi\n$$\n\n## まとめ\n\nTypeScriptを効果的に使用することで、開発体験と製品の品質を大幅に向上させることができます。継続的に学習し、ベストプラクティスを取り入れていきましょう。\n",
  "modifiedDate": "2025-11-16T12:26:30.257Z"
}